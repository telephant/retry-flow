function t(t,i,e,r){return new(e||(e=Promise))((function(s,n){function o(t){try{h(r.next(t))}catch(t){n(t)}}function u(t){try{h(r.throw(t))}catch(t){n(t)}}function h(t){var i;t.done?s(t.value):(i=t.value,i instanceof e?i:new e((function(t){t(i)}))).then(o,u)}h((r=r.apply(t,i||[])).next())}))}var i;"function"==typeof SuppressedError&&SuppressedError,function(t){t[t.times=1]="times",t[t.duration=2]="duration"}(i||(i={}));class e{constructor(){this._callback=null,this._interval=3e3,this._timeout=5e3,this._retryTimes=3,this._retryDuration=5e3,this._retryType=i.times,this._curRetryTimes=0,this._checkPassFn=null,this._stopWhenFn=null,this._durationStartTime=0,this._waitTimer=null}func(t){if("function"!=typeof t)throw new Error("func accept callback as Function type");return this._callback=t,this}interval(t){return this._interval=t,this}timeout(t){return this._timeout=t,this}retryTimes(t){return this._retryType=i.times,this._retryTimes=t,this}retryDuration(t){return this._retryType=i.duration,this._retryDuration=t,this}checkPass(t){return this._checkPassFn=t,this}stopWhen(t){return this._stopWhenFn=t,this}wait(i){return t(this,void 0,void 0,(function*(){return new Promise((t=>this._waitTimer=setTimeout(t,i)))}))}start(){return t(this,void 0,void 0,(function*(){if(!this._callback)throw new Error("func() should be invoked before start()");return new Promise(((t,e)=>{switch(this._retryType){case i.times:return this._startTimes(t,e);case i.duration:return this._durationStartTime=Date.now(),this._startDuration(t,e);default:e("error retry type")}}))}))}_startTimes(i,e){return t(this,void 0,void 0,(function*(){if(!this._callback)return void e("func() should be invoked before start()");let r=null;const s=()=>{r&&clearTimeout(r)},n=r=>t(this,void 0,void 0,(function*(){if(s(),!this._increaseTimes())return this._clearTimes(),void e(null!=r?r:`exceed max retry times - ${this._retryTimes}`);yield this.wait(this._interval),yield this._startTimes(i,e)}));r=setTimeout(n,this._timeout),yield this._excuteCb({success:e=>t(this,void 0,void 0,(function*(){s(),this._clearTimes(),i(e)})),fail:i=>t(this,void 0,void 0,(function*(){yield n(i)})),stop:()=>t(this,void 0,void 0,(function*(){s(),this._clearTimes(),e("stop when stopWhen")}))})}))}_startDuration(i,e){return t(this,void 0,void 0,(function*(){if(!this._callback)return void e("func() should be invoked before start()");const r=r=>t(this,void 0,void 0,(function*(){if(!this._inDuration())return this._clearDuration(),void e(null!=r?r:`exceed retry durantion ${this._retryDuration}`);yield this.wait(this._interval),yield this._startDuration(i,e)}));yield this._excuteCb({success:e=>t(this,void 0,void 0,(function*(){this._clearDuration(),i(e)})),fail:i=>t(this,void 0,void 0,(function*(){yield r(i)})),stop:()=>t(this,void 0,void 0,(function*(){this._clearDuration(),e("stop when stopWhen")}))})}))}_excuteCb(i){var e;return t(this,void 0,void 0,(function*(){const{success:t,fail:r,stop:s}=i;let n;try{if(n=yield null===(e=this._callback)||void 0===e?void 0:e.call(this),this._stopWhenFn&&this._stopWhenFn(n))return void(yield s());if(this._checkPassFn&&!this._checkPassFn(n))return void(yield r());yield t(n)}catch(t){yield r(t)}}))}_increaseTimes(){return!(this._curRetryTimes>=this._retryTimes)&&(this._curRetryTimes++,!0)}_inDuration(){return!(Date.now()-this._durationStartTime>this._retryDuration-this._interval)}_clearTimes(){this._curRetryTimes=0}_clearDuration(){this._durationStartTime=0,this._waitTimer&&clearTimeout(this._waitTimer)}}export{e as default};
